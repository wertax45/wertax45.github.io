[{"title":"Hello World","url":"/2025/12/21/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["other"],"tags":["other"]},{"title":"python关键词表","url":"/2025/12/21/python%E5%85%B3%E9%94%AE%E8%AF%8D%E8%A1%A8/","content":"以下是 Python 3.12 中的完整关键词列表及其分类说明：\n\n\n\n关键词\n类别\n简要说明\n\n\n\nFalse\n常量值\n布尔假值\n\n\nNone\n常量值\n空值对象\n\n\nTrue\n常量值\n布尔真值\n\n\nand\n逻辑运算符\n逻辑与操作\n\n\nas\n别名操作\n创建别名（with&#x2F;import）\n\n\nassert\n调试\n断言检查\n\n\nasync\n异步编程\n定义异步函数&#x2F;上下文\n\n\nawait\n异步编程\n等待异步操作完成\n\n\nbreak\n流程控制\n跳出循环\n\n\nclass\nOOP\n定义类\n\n\ncontinue\n流程控制\n跳过当前循环迭代\n\n\ndef\n函数定义\n定义函数\n\n\ndel\n内存管理\n删除对象引用\n\n\nelif\n条件判断\nelse if 的缩写\n\n\nelse\n条件判断\n条件分支\n\n\nexcept\n异常处理\n捕获异常\n\n\nfinally\n异常处理\n无论是否异常都执行的代码块\n\n\nfor\n循环控制\nfor 循环\n\n\nfrom\n模块导入\n从模块导入特定对象\n\n\nglobal\n变量作用域\n声明全局变量\n\n\nif\n条件判断\n条件语句\n\n\nimport\n模块导入\n导入模块\n\n\nin\n成员操作符\n检查成员存在&#x2F;循环迭代\n\n\nis\n对象比较\n对象标识比较（内存地址）\n\n\nlambda\n函数定义\n创建匿名函数\n\n\nnonlocal\n变量作用域\n声明非局部变量（闭包）\n\n\nnot\n逻辑运算符\n逻辑非操作\n\n\nor\n逻辑运算符\n逻辑或操作\n\n\npass\n空操作\n占位语句（不做任何操作）\n\n\nraise\n异常处理\n抛出异常\n\n\nreturn\n函数控制\n从函数返回值\n\n\ntry\n异常处理\n尝试执行可能出错的代码块\n\n\nwhile\n循环控制\nwhile 循环\n\n\nwith\n上下文管理\n上下文管理器（资源管理）\n\n\nyield\n生成器\n从生成器返回值\n\n\n","categories":["python"],"tags":["python"]},{"title":"基础-函数","url":"/2025/12/21/%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0/","content":"\n定义一个函数def 函数名(data&#x2F;传入数据&#x2F;不需要传入参数时可空下):    执行语句    return 返回值 （用不到可省略整行）\ndef hi():      print(&quot;HI!&quot;)    hi() # 最简单的调用方式\n\n\n函数是:组织好的、可重复使用的、用来实现特定功能的代码段\n使用函数的好处是:将功能封装在函数内，可供随时随地重复利用提高代码的复用性，减少重复代码，提高开发效率\n注意事项参数如不需要，可以省略(后续章节讲解)返回值如不需要，可以省略(后续章节讲解)函数必须先定义后使用\n\ndef my_len(data):      c = 0      for i in data:          c += 1      print(&quot;strlen = %d&quot; % c)      return c # 在没有变量接受该值时，可以省略      v = &quot;can you count this?&quot;  my_len(v)\n\n函数的传入参数传入参数的功能是:在函数进行计算的时候，接受外部(调用时)提供的数据\n有如下代码，完成了2个数字相加的功能：\ndef add():\tresult = 1 + 2\tprintf(f&quot;1 + 2 的结果是：&#123;result&#125;&quot;)\t# 使用传入参数def add(x, y):\tresult = x + y\tprint(f&quot;&#123;x&#125; + &#123;y&#125; 的结果是：&#123;result&#125;&quot;)\n\n使用传入参数：def  函数名(x&#x2F;参数1,y&#x2F;参数2):    函数体    return 返回值\n传入参数的数量是没有限制的，任意个（0~N）\n\n函数定义中，提供的x和y，称之为:形式参数(形参)，表示函数声明将要使用2个参数参数之间使用逗号进行分隔\n函数调用中，提供的5和6，称之为:实际参数(实参)，表示函数执行时真正使用的参数值传入的时候，按照顺序传入数据，使用逗号分隔\n\n函数的返回值\n什么是函数返回值? 函数在执行完成后，返回给调用者的结果。函数在本质上都是有返回值的\n\n返回值的应用语法 使用关键字:return 来返回结果\n\n\ndef say_hello():\tprint(&quot;hello!&quot;)# 用变量接收say_hello()的返回值，此时值为noneresult = say_hello()print(result)\n\n\n注意: 函数体在遇到return后就结束了，所以写在return后的代码不会执行。\n\nNone类型的返回值如果函数没有使用return语句返回数据，那么函数有返回值吗?实际上是：有的。\nPython中有一个特殊的字面量:None，其类型是：&lt;class ‘NoneType’&gt;无返回值的函数，实际上就是返回了：None这个字面量None表示:空的、无实际意义的意思函数返回的None，就表示，这个函数没有返回什么有意义的内容。也就是返回了空的意思。\nNone可以主动使用return返回，效果等同于不写return语句\ndef say_hello():\tprint(&quot;hello!&quot;)\treturn None\n\nNone使用场景：函数返回值；if判断；变量定义\n函数的说明文档\n函数说明文档的作用是? 对函数进行说明解释，帮助更好理解函数的功能\n\n定义语法\n\n\ndef func(x, y):\t&quot;&quot;&quot;\t函数说明\t:param x: 参数X的说明\t:param y: 参数y的说明\t:return: 返回值说明\t这里的内容会在鼠标悬停时显示\t&quot;&quot;&quot;\t函数体\treturn 返回值\n\n函数的嵌套调用\n什么是嵌套调用 在一个函数中，调用另外一个函数\n\n执行流程 函数A中执行到调用函数B的语句，会将函数B全部执行完成后，继续执行函数A的剩余内容\n\n\ndef func_b():\tprint(&quot;---2---&quot;)\tdef func_a():\tprint(&quot;---1---&quot;)\tdef func_c():\tprint(&quot;---3---&quot;)# 调用函数func_afunc_a()\n\n输出：\nG:\\Py4PY\\.venv\\.venv\\bin\\python.exe G:\\Py4PY\\spj\\function_selfuse\\f2.py ---1------2------3---\n\n\n变量在函数中的作用域变量作用域指的是变量的作用范围（变量在哪里可用，在哪里不可用），主要分为两类：局部变量&#x2F;全局变量\n\n什么是局部变量 作用范围在函数内部，在函数外部无法使用 所谓局部变量是定义在函数体内部的变量，即只在函数体内部生效def testA():\tnum = 100\tprint(num)testA() # 100print(num)# 报错:name &#x27;num&#x27;is not defined\n变量a是定义在 testA() 函数内部的变量，在函数外部访问则立即报错\n\n局部变量的作用：在函数体内部，临时保存数据，即当函数调用完成后，则销毁局部变量\n\n什么是全局变量 在函数内部和外部均可使用\n\n如何将函数内定义的变量声明为全局变量 使用global关键字，global变量\n\n\n函数与方法函数是一个封装的代码单元，可以提供特定功能。在Python中，如果将函数定义为class(类)的成员，那么函数会称之为：方法\n函数：\ndef add(x, y):\treturn x + y\n\n方法：\nclass Student:\tdef add(self,x,y):\t\treturn x + y\n\n方法和函数功能一样，有传入参数，有返回值，只是方法的使用格式不同\n函数的使用：\nnum = add(1, 2)\n\n方法的使用：\nstudent = Student()# 先赋给变量num = student.add(1,2)# 然后使用add方法","categories":["python"],"tags":["python"]},{"title":"连通分量","url":"/2025/12/21/%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/","content":"连通分量（Connected Component） 是图论中的核心概念，用于描述图的连通性。其定义和特性如下：\n\n1. 核心定义\n连通分量 是无向图中的一个 极大连通子图，满足：\n连通性：子图中任意两个顶点之间都存在路径。\n极大性：不能再添加新的顶点（否则会破坏连通性）。\n\n\n\n\n2. 关键特性\n\n\n属性\n说明\n\n\n\n独立性\n不同连通分量之间互不连通（无边连接）。\n\n\n顶点覆盖\n每个顶点属于且仅属于一个连通分量。\n\n\n无向图专用\n概念仅适用于无向图（有向图的对应概念是 强连通分量）。\n\n\n\n3. 直观示例无向图示例：graph LR  A --- B  C --- D  E --- F  F --- G\n\n连通分量 1：&#123;A, B&#125;（A 和 B 相连）。\n连通分量 2：&#123;C, D&#125;（C 和 D 相连）。\n连通分量 3：&#123;E, F, G&#125;（E、F、G 彼此相连）。\n\n\n✅ 结论：此图有 3 个连通分量。\n\n\n4. 有向图的扩展：强连通分量有向图的连通性更复杂，需引入 强连通分量（Strongly Connected Component, SCC）：\n\n定义：有向图的一个子图，其中任意两个顶点 (u) 和 (v) 均存在 双向路径（(u \\to v) 和 (v \\to u)）。\n示例：graph LR  A --&gt; B  B --&gt; C  C --&gt; A  D --&gt; E\n\n强连通分量 1：&#123;A, B, C&#125;（三者可互相到达）。\n强连通分量 2：&#123;D&#125;（D 是孤立点）。\n强连通分量 3：&#123;E&#125;（E 是孤立点）。\n\n\n\n\n5. 应用场景\n网络诊断：识别互联网中断开的子网。\n社交网络：分析用户群体中的独立圈子（如微信好友圈）。\n编译器优化：检测代码中的独立模块。\n\n\n6. 算法实现\n无向图连通分量：使用 DFS&#x2F;BFS 遍历图，每次遍历得到一个连通分量。def find_components(graph):    visited = set()    components = []    for node in graph:        if node not in visited:            comp = []            dfs(node, visited, comp, graph)            components.append(comp)    return components\n有向图强连通分量：常用 Kosaraju 算法 或 Tarjan 算法。\n\n\n总结\n无向图：连通分量 &#x3D; 极大连通子图。\n有向图：强连通分量 &#x3D; 极大双向连通子图。\n核心价值：揭示图的内部结构，将复杂图分解为独立连通块。\n\n","categories":["C/C++"],"tags":["C/C++"]},{"title":"基础-1","url":"/2025/12/21/%E5%9F%BA%E7%A1%80-1/","content":"\n截至到for循环，最后一次编辑时间：25&#x2F;6&#x2F;8\n\n字面量字面量，代码中的固定值  ，如下\nx = 123 y = 12.5z = &#x27;what?&#x27;\n格式：变量名 &#x3D; 变量值\n注释单行注释：# 单行注释，记得开头空1格多行注释：\n&quot;&quot;&quot;1.2. 这是多行注释  3.&quot;&quot;&quot;\n\n基本数据类型三种基本的数据类型：string, int, float\nprint(&quot;???&quot;)# 1.字符串  print(123)# 2.int  print(3.1415926)# 3.浮点数  print(&quot;one line&quot;,end=&#x27;&#x27;)# 使用end=&#x27;&#x27;来取消换行  \n\n使用type()来查看数据类型 \nprint(type(&quot;123&quot;)) # 使用type()来查看括号内的数据类型  whats_TYPE_is_this = 123  print(type(whats_TYPE_is_this)) # 另一种用法  is_this_int = type(123)  print(is_this_int)  \n\n其他数据类型：\n图先欠着\n数据类型转换与C&#x2F;C++一样，PY可以使用自带的强制类型转换基本数据类型：\nint(x)  str(x)  float(x)\n\n其他类型：\nbool(x)# 转换为布尔值list(x)# 转换为列表tuple(x)# 转换为元组set(x)# 转换为集合dict(x)# 转换为字典\n\n\n标识符标识符可以是下面的样子：A   _A   _a1   a1  变量1\n数字不能在前，区分大小写  \nPython 的关键词（也称为保留字）是语言中具有特殊含义的单词，不能用作变量名、函数名或其他标识符。完整关键词列表：python关键词表\n运算符7种数学运算：\n+，-，*，/  //求整数，**求指数，%求余数  \n\n对应7种赋值运算符：\n+=，-=，*=，/=，//=，**=，%= \n\n\n运算符使用例：\ns = 1  s = s + 3# or  s += 3# they are the same  \n\n\n字符串的三种定义方式字符串有3种定义法：\ns1 = &quot;&quot;&quot;HI&quot;&quot;&quot;s2 = &quot;hello?&quot;s3 = &#x27;well...&#x27;\n\n 使用：\np1 = &quot;&quot;&quot;Hmmm&quot;&quot;&quot;  p2 = &#x27; say &quot;HI&quot; to him.&#x27;# 使用&#x27;&#x27;以打印&quot;&quot;  p3 = &quot; \\&quot;\\&quot;nope? well...  &quot;# 使用\\以取消&quot;的功能  p4 = &quot; It&#x27;s fine.&quot;  print(p1,p2,p3,p4)# 在同一行的多项输出  \n python的输出自带回车\n连接字符串 &#x2F; 拼接字符串：\nprint(&quot;pop&quot; + &quot; up!&quot;)# 字符串用 + 连接  print(&quot;pop &quot; + p1 + &quot; out&quot;)# 可以连接字符串变量  \n\n字符串格式化格式化字符串，可以使用占位的方法格式化输出，与C&#x2F;C++的格式化输出相同\n格式符分别为：%s字符串 , %f浮点数 , %d整数\nt1 = 9  print(&quot;It&#x27;s %s&quot; % t1 + &quot;AM&quot;)# 使用%s来占位，以输出非字符串类型的数据  n1 = 2  n2 = 1  print(&quot;We have %s friends comes from the %s area. &quot; % (n1,n2))# 数字将被 转为 字符串并输出  \n\n\n字符串格式化精度控制输出精度控制：  \n%5d跟C&#x2F;C++一样，但当数字大于5时，格式不生效  \n%5.3f还是C &#x2F;C++ \n%.2f小数超出的部分会四舍五入\n另一种格式化字符串的办法（原样输出）：f”{变量名}”  \np5 = 123  print(f&quot;We have &#123;p5&#125; apples.&quot;)  \n\n格式化输出也可以从表达式入手，不再使用变量下面是 格式化表达式 的写法：\nprint(&quot;1 * 1 = %d&quot; % (1*1))  print(f&quot;2 * 1 = &#123;2 * 1&#125;&quot;)  print(&quot;string type : %s&quot; % type(&quot;any str here&quot;))# type()的结果是字符串类型哦  \n\n\n数据输入（input语句）输入 ：input()  \n可以将提示信息放入input()中input()会将输入的所有信息转为字符串处理，如需要其他类型需要手动转换 \nname = input(&quot;enter your name pls:&quot;)  name = str(name)# 输入的类型为str  print(&quot;good to see you, %s&quot; % name)  day = int(input(&quot;What&#x27;s your lucky number?&quot;))# 将输入的str类型转换为intprint(&quot;Nice pick!&quot;)  \n\n布尔类型与比较运算符布尔类型可以通过 直接赋值 或进行 比较运算 来得到x &#x3D; True  or  x &#x3D; 1 &lt; 2 \nb1 = 1&lt;2  print(f&quot;b1 = &#123;type(b1)&#125;&quot;)  \n输出为bool\nif语句python的if是通过缩进来判断归属的，4个空格 else 同理多个条件可以使用elif，（就像switch）\nif-else格式：if 条件:    执行语句1else    执行语句2\nif-elif-else格式：if 条件1:    执行语句1    …elif 条件2:    执行语句1    …elif 条件3:    执行语句1    …else 条件都不满足时的执行语句    # 如果不写else，则elif &#x3D;&#x3D; if \nif name == &quot;NULL&quot;:      print(&quot;well?&quot;)  else:      print(&quot;whatever&quot;)  \n\n程序案例：nope\nwhile 循环格式：while 循环条件:    执行的语句，需要缩进\ni = 0  while i&lt;100:      i += 1  \n\n程序案例：nope\nfor循环格式：for 临时变量 in 数据集&#x2F;序列类型:    执行代码1\nfor 无法定义循环条件，只能被动取出数据处理\n案例，找出字符串中a的数量：\nword = &quot;Would you have let me if I asked?&quot;  x = 0  for i in word:      if i == &quot;a&quot;:# 找出字符串中a的数量          x += 1  print(x)\n\n\n基本定义Python 提供了两种循环结构：  \n\nwhile 循环：通过自定义条件控制循环  \nfor 循环：通过轮询机制对内容进行逐个处理\n\n\nfor循环本质 “for循环就是将‘待办事项’逐个完成的循环机制”\n\n运行流程  \ngraph LRA[开始循环] --&gt; B&#123;是否有下一个元素？&#125;B --&gt;|是| C[处理当前元素]C --&gt; BB --&gt;|否| D[结束循环]\n\n关键特性  \n\n自动遍历可迭代对象（如数字序列 1→2→3→4→5→6）\n无需手动维护计数器\n内置终止检测机制\n\n\n\n","categories":["python"],"tags":["python"]},{"title":"基础-2","url":"/2025/12/21/%E5%9F%BA%E7%A1%80-2/","content":"range语句range(a)  生成一个 0~a 的数据集\nrange(a,b)  可以生成一个 a~b-1 的数据集\nrange(a,b,step)  step为步长，即跳跃多少步取一个数字  如: range(1,10,2)  取出：1，3，5，7，9\nnum = 100  i = 0  for x in range(1,num):      if x % 2 == 0:          i += 1          print(&quot;一共有%d个偶数&quot; % i)\n\ncontinue 和 breakPython提供continue和break关键字用以对循环进行临时跳过和直接结束\ncontinue关键字用于:    中断本次循环，直接进入下一次循环，continue可以用于for循环和while循环，效果一致\nfor i in range(1,100):\t语句1\tcontinue\t语句2\n在循环内，遇到continue就结束当次循环，进行下一次。语句2是不会执行的。\nbreak关键字用于:    直接结束循环，可以用于for循环和while循环，效果一致\nfor i in range(1,100):\t语句1\tbreak\t语句2语句3\n在循环内，遇到break就结束循环了。执行了语句1后，直接执行语句3了\n","categories":["python"],"tags":["python"]},{"title":"基础-3","url":"/2025/12/22/%E5%9F%BA%E7%A1%80-3/","content":"数据容器Python中的数据容器:    一种可以容纳多份数据的数据类型，容纳的每一份数据称之为1个元素每一个元素，可以是任意类型的数据，如字符串、数字、布尔等\n\n\n数据容器根据特点的不同，如：是否支持重复元素、 列表是否可以修改、是否有序，等分为5类，分别是:\n列表(list)、元组(tuple)、字符串(str)、集合(set)、字典(dict)\n列表数据容器：list列表语法：[元素1,元素2...]\n什么是元素?数据容器内的每一份数据，都称之为元素\n元素的类型有限制吗?元素的数据类型没有任何限制，甚至元素也可以是列表，这样就定义了嵌套列表\n1. 列表的定义列表可以一次存储多个数据，且可以为不同的数据类型，支持嵌套\n# 定义一个列表，元素类型任意  [1,&quot;hi&quot;,2.5,[1,2,3]]# 字面量  my_list = [1,&quot;hi&quot;,2.5,[1,2,3]]# 定义一个嵌套列表  my_list2 = [[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],[4,5,6],[True,False]]# 3个元素\n\n2. 列表的下标索引如何从列表中取出特定位置的数据呢?我们可以使用：下标索引\n\n如图，列表中的每一个元素，都有其位置下标索引，从前向后的方向，从0开始，依次递增我们只需要按照下标索引，即可取得对应位置的元素。\n\n# 通过下标索引取出对应元素  my_list3 = [&quot;a1&quot;,&#x27;b1&#x27;,&#x27;c1&#x27;]# 正向，从0开始：0，1，2，如果超出范围会报错  print(my_list3[0])\n\n\n或者，可以反向索引，也就是从后向前:从-1开始，依次递减(-1、-2、-3……\n\n\n如图，从后向前，下标索引为:-1、-2、-3，依次递减。\n\n# 通过下标索引倒序取出对应元素  my_list4 = [3,2,1]  print(my_list4[-1])# 倒序，从右到左数，加上负号，依次为：-3,-2,-1\n\n\n如果列表是嵌套的列表，同样支持下标索引\n\n\n有点像二维数组 :\\\n\n# 取出嵌套列表的元素  my_list5 = [[1,2,3],[3,4,5]]  print(my_list5[0][0])\n\n\n总结：\n\n列表的下标索引是什么?  列表的每一个元素，都有编号称之为下标索引从前向后的方向，编号从0开始递增  从后向前的方向，编号从-1开始递减\n\n如何通过下标索引取出对应位置的元素呢?  列表[下标]，即可取出\n\n下标索引的注意事项  要注意下标索引的取值范围，超出范围无法取出元素，并且会报错\n\n\n3. 列表的常用操作列表除了可以:\n\n定义\n\n使用下标索引获取值以外，列表也提供了一系列功能:插入元素\n\n删除元素\n清空列表\n修改元素\n统计元素个数等等功能，这些功能我们都称之为:列表的方法\n\n元组coming soon(?)\n","categories":["python"],"tags":["python"]},{"title":"关于该站点","url":"/2025/12/22/%E5%85%B3%E4%BA%8E%E8%AF%A5%E7%AB%99%E7%82%B9/","content":"技术实现与工具1.技术栈呈现方案：hexo + github pages + git + Async theme\n该站点的技术栈清单，包括但不限于：\n\n\n\n技术栈分类\n具体技术\n用途&#x2F;功能\n版本&#x2F;备注\n\n\n\n静态站点生成器\nHexo\n将Markdown文档转换为静态HTML页面\nNode.js驱动，支持主题和插件\n\n\n前端框架\nNode.js\nHexo运行环境，JavaScript服务端运行时\n建议使用LTS版本\n\n\n模板引擎\nEJS&#x2F;Swig&#x2F;其他\n主题模板渲染，页面布局生成\nHexo默认支持EJS，主题可自定义\n\n\nCSS预处理器\nStylus&#x2F;Sass&#x2F;Less\n样式表编写和编译\nAsync主题可能使用Stylus\n\n\n前端构建工具\nHexo内置构建系统\n资源处理、页面生成、优化\n基于Node.js流处理\n\n\n主题框架\nAsync主题\n提供博客UI界面和交互功能\n基于Hexo主题规范开发\n\n\nJavaScript库\njQuery&#x2F;原生JS\n前端交互和动态效果\nAsync主题可能包含\n\n\nMarkdown解析器\nMarked&#x2F;hexo-renderer-marked\n将Markdown转换为HTML\n可配置扩展语法\n\n\n代码高亮\nHexo 自带的代码渲染\n代码块的语法高亮显示\n\n\n\n搜索功能\nLocal Search&#x2F;Algolia\n站内文章搜索\nAsync主题集成本地搜索\n\n\n评论系统\nValine&#x2F;Waline&#x2F;Gitalk\n文章评论功能\n需要第三方服务支持\n\n\n统计与分析\nGoogle Analytics&#x2F;Baidu Tongji\n访问数据统计\n通过主题配置添加\n\n\n部署与托管\nGitHub Pages\n静态网站免费托管服务\n自动SSL，自定义域名\n\n\n版本控制\nGit\n源码和文章版本管理\n分布式版本控制系统\n\n\n持续集成&#x2F;部署\nGitHub Actions\n自动化构建和部署流程\n可配置workflow文件\n\n\nSEO优化\nsitemap.xml&#x2F;robots.txt\n搜索引擎优化\nHexo插件自动生成\n\n\n数学公式\nKaTeX\n数学公式渲染\n科技博客常用\n\n\n流程图&#x2F;图表\nMermaid&#x2F;Flowchart.js\n绘制流程图和图表\n部分主题支持\n\n\n图标字体\nFont Awesome5&#x2F;阿里图标库\n界面图标展示\n提升视觉体验\n\n\n技术依赖关系：\nNode.js (基础环境)    ↓   Hexo (博客框架)    ├── hexo-cli (命令行工具)    ├── hexo-server (本地服务器)    ├── hexo-deployer-git (部署插件)    └── 其他插件生态系统    ↓Async主题 (界面呈现)    ├── 模板引擎 (EJS)    ├── CSS预处理器 (Stylus/Sass)    └── JavaScript交互    ↓GitHub生态系统    ├── GitHub Pages (托管)    ├── GitHub Actions (CI/CD)    └── GitHub API (集成服务)\n\n这套技术栈结合了现代Web开发的多个方面，形成了一个完整、高效且免费的博客发布系统。\n2.工具主要的且有GUI的 ：VS code，git，Obsidian，PS（？）\n项目亮点\n完全免费: GitHub Pages提供免费托管和SSL证书\n快速部署: 推送代码到GitHub即可自动更新\n版本可控: 所有文章和配置都有Git版本历史\n高度可定制: 主题和插件系统提供无限扩展可能\n性能优秀: 静态页面加载速度快\n\n代码亮点1. 前端工具链// Hexo 插件生态系统（部分示例）const techStack = &#123;  buildTools: &#123;    hexo: &quot;v7.0+&quot;,              // 基于Node.js的现代化静态生成器    postProcessor: &quot;hexo-filter-optimize&quot;, // 自动优化CSS/JS/HTML    imageOptimizer: &quot;hexo-filter-responsive-images&quot; // 响应式图片  &#125;,    // Async主题的特色功能  asyncTheme: &#123;    darkMode: &quot;自动/手动切换 + 本地存储&quot;,    readingProgress: &quot;实时阅读进度条&quot;,    smoothScroll: &quot;原生JS平滑滚动&quot;,    codeBlock: &quot;Prism.js + 行号 + 复制按钮&quot;,    lazyLoad: &quot;Intersection Observer API&quot;,    pwa: &quot;Service Worker + Manifest&quot;  &#125;&#125;;\n\n2. 性能优化# Hexo优化插件配置示例optimization:  css_minifier: &quot;clean-css&quot;  js_minifier: &quot;terser&quot;  html_minifier: &quot;html-minifier&quot;  cdn_provider: &quot;jsDelivr&quot;    # 关键优化  critical_css: true           # 首屏关键CSS内联  preload_links: true          # 资源预加载  prefetch_links: true         # 链接预获取  service_worker: true         # PWA离线缓存\n\n3.炫酷第三方库KaTeX - 数学公式\n交互与动画：\n\n\n\n库名\n功能\n炫酷特性\n\n\n\nFuse.js\n本地搜索\n模糊搜索 + 权重匹配\n\n\nTyped.js\n打字机效果\n动态文字输入动画\n\n\nAOS\n滚动动画\n元素进入视口动画\n\n\nPhotoSwipe\n图片画廊\n响应式灯箱效果\n\n\n异步加载与性能：\n// Async主题的核心异步加载策略const asyncLoading = &#123;  // 图片懒加载  lazyLoad: &quot;lozad.js 或原生 IntersectionObserver&quot;,    // 组件懒加载  components: &#123;    comments: &quot;评论系统按需加载&quot;,    analytics: &quot;统计代码异步加载&quot;,    social: &quot;分享按钮延迟加载&quot;  &#125;,    // 预加载策略  preload: &#123;    critical: &quot;首屏资源&quot;,    hover: &quot;悬停预加载&quot;,    visible: &quot;视口内预加载&quot;  &#125;&#125;;\n\n\n问题&amp;解决Q：图片太大，全放到github上加载慢怎么办？\nA：直接使用互联网上的公开图片资源（如banner），或者在线图床，这里是两者都有。还可以从图片入手，脚本批量&#x2F;手动 压缩（100%有损，但能用）\n总结&amp;展望这套方案最大的亮点是用最简单的技术栈实现了专业级博客的所有功能，同时保持了极佳的性能和可维护性。（掉头发.ing）\n未来会考虑使用github图床+PicGo+CDN加速，处理图片资源\n可选扩展：选择评论方案，友链，相册页，想起什么加什么\n","categories":["other"],"tags":["other"]}]